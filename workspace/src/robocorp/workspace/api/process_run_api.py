# coding: utf-8

"""
    Robocorp Control Room API

    Robocorp Control Room API

    The version of the OpenAPI document: 1.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


import re  # noqa: F401
import io
import warnings

from pydantic import validate_call, ValidationError
from typing import Dict, List, Optional, Tuple

from pydantic import Field
from typing_extensions import Annotated
from pydantic import StrictFloat, StrictInt, StrictStr, field_validator

from typing import Optional, Union

from robocorp.workspace.models.any_valid_json import AnyValidJson
from robocorp.workspace.models.delete_worker200_response import DeleteWorker200Response
from robocorp.workspace.models.list_process_run_outputs200_response import ListProcessRunOutputs200Response
from robocorp.workspace.models.list_process_runs200_response import ListProcessRuns200Response
from robocorp.workspace.models.process_run_resource import ProcessRunResource
from robocorp.workspace.models.start_process_run200_response import StartProcessRun200Response
from robocorp.workspace.models.start_process_run_qs_auth200_response import StartProcessRunQsAuth200Response
from robocorp.workspace.models.start_process_run_request import StartProcessRunRequest
from robocorp.workspace.models.stop_process_run200_response import StopProcessRun200Response
from robocorp.workspace.models.stop_process_run_request import StopProcessRunRequest

from robocorp.workspace.api_client import ApiClient
from robocorp.workspace.api_response import ApiResponse
from robocorp.workspace.exceptions import (  # noqa: F401
    ApiTypeError,
    ApiValueError
)


class ProcessRunApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client

    @validate_call
    def delete_process_run(
        self,
        workspace_id: Annotated[StrictStr, Field(description="The id of the workspace on which the robot resides.")],
        process_run_id: Annotated[StrictStr, Field(description="The id of the process run to delete.")],
        **kwargs,
    ) -> DeleteWorker200Response:
        """Delete process run  # noqa: E501

        Deletes a process run. This action is irreversible!  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.delete_process_run(workspace_id, process_run_id, async_req=True)
        >>> result = thread.get()

        :param workspace_id: The id of the workspace on which the robot resides. (required)
        :type workspace_id: str
        :param process_run_id: The id of the process run to delete. (required)
        :type process_run_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: DeleteWorker200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the delete_process_run_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)

        return self.delete_process_run_with_http_info.raw_function(
            workspace_id,
            process_run_id,
            **kwargs,
        )

    @validate_call
    def delete_process_run_with_http_info(
        self,
        workspace_id: Annotated[StrictStr, Field(description="The id of the workspace on which the robot resides.")],
        process_run_id: Annotated[StrictStr, Field(description="The id of the process run to delete.")],
        **kwargs,
    ) -> ApiResponse:
        """Delete process run  # noqa: E501

        Deletes a process run. This action is irreversible!  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.delete_process_run_with_http_info(workspace_id, process_run_id, async_req=True)
        >>> result = thread.get()

        :param workspace_id: The id of the workspace on which the robot resides. (required)
        :type workspace_id: str
        :param process_run_id: The id of the process run to delete. (required)
        :type process_run_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(DeleteWorker200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'workspace_id',
            'process_run_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_process_run" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats: Dict[str, str] = {}

        # process the path parameters
        _path_params: Dict[str, str] = {}
        if _params['workspace_id'] is not None:
            _path_params['workspace_id'] = _params['workspace_id']

        if _params['process_run_id'] is not None:
            _path_params['process_run_id'] = _params['process_run_id']


        # process the query parameters
        _query_params: List[Tuple[str, str]] = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings: List[str] = ['API Key with permissions']  # noqa: E501

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "DeleteWorker200Response",
            '400': "GenericErrorResponse",
            '403': "GenericErrorResponse",
            '404': "GenericErrorResponse",
            '409': "GenericErrorResponse",
        }

        return self.api_client.call_api(
            '/workspaces/{workspace_id}/process-runs/{process_run_id}', 'DELETE',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_call
    def get_process_run(
        self,
        workspace_id: Annotated[StrictStr, Field(description="Workspace ID")],
        process_run_id: Annotated[StrictStr, Field(description="ID of the process run")],
        **kwargs,
    ) -> ProcessRunResource:
        """Get process run  # noqa: E501

        Returns a process run  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_process_run(workspace_id, process_run_id, async_req=True)
        >>> result = thread.get()

        :param workspace_id: Workspace ID (required)
        :type workspace_id: str
        :param process_run_id: ID of the process run (required)
        :type process_run_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ProcessRunResource
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the get_process_run_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)

        return self.get_process_run_with_http_info.raw_function(
            workspace_id,
            process_run_id,
            **kwargs,
        )

    @validate_call
    def get_process_run_with_http_info(
        self,
        workspace_id: Annotated[StrictStr, Field(description="Workspace ID")],
        process_run_id: Annotated[StrictStr, Field(description="ID of the process run")],
        **kwargs,
    ) -> ApiResponse:
        """Get process run  # noqa: E501

        Returns a process run  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_process_run_with_http_info(workspace_id, process_run_id, async_req=True)
        >>> result = thread.get()

        :param workspace_id: Workspace ID (required)
        :type workspace_id: str
        :param process_run_id: ID of the process run (required)
        :type process_run_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ProcessRunResource, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'workspace_id',
            'process_run_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_process_run" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats: Dict[str, str] = {}

        # process the path parameters
        _path_params: Dict[str, str] = {}
        if _params['workspace_id'] is not None:
            _path_params['workspace_id'] = _params['workspace_id']

        if _params['process_run_id'] is not None:
            _path_params['process_run_id'] = _params['process_run_id']


        # process the query parameters
        _query_params: List[Tuple[str, str]] = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings: List[str] = ['API Key with permissions']  # noqa: E501

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ProcessRunResource",
            '403': "GenericErrorResponse",
            '404': "GenericErrorResponse",
        }

        return self.api_client.call_api(
            '/workspaces/{workspace_id}/process-runs/{process_run_id}', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_call
    def list_process_run_outputs(
        self,
        workspace_id: Annotated[StrictStr, Field(description="Workspace ID")],
        process_run_id: Annotated[StrictStr, Field(description="Process Run ID")],
        limit: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Limit for paginated response")] = None,
        **kwargs,
    ) -> ListProcessRunOutputs200Response:
        """List process run outputs  # noqa: E501

        Returns a list of process run outputs.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.list_process_run_outputs(workspace_id, process_run_id, limit, async_req=True)
        >>> result = thread.get()

        :param workspace_id: Workspace ID (required)
        :type workspace_id: str
        :param process_run_id: Process Run ID (required)
        :type process_run_id: str
        :param limit: Limit for paginated response
        :type limit: float
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ListProcessRunOutputs200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the list_process_run_outputs_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)

        return self.list_process_run_outputs_with_http_info.raw_function(
            workspace_id,
            process_run_id,
            limit,
            **kwargs,
        )

    @validate_call
    def list_process_run_outputs_with_http_info(
        self,
        workspace_id: Annotated[StrictStr, Field(description="Workspace ID")],
        process_run_id: Annotated[StrictStr, Field(description="Process Run ID")],
        limit: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Limit for paginated response")] = None,
        **kwargs,
    ) -> ApiResponse:
        """List process run outputs  # noqa: E501

        Returns a list of process run outputs.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.list_process_run_outputs_with_http_info(workspace_id, process_run_id, limit, async_req=True)
        >>> result = thread.get()

        :param workspace_id: Workspace ID (required)
        :type workspace_id: str
        :param process_run_id: Process Run ID (required)
        :type process_run_id: str
        :param limit: Limit for paginated response
        :type limit: float
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ListProcessRunOutputs200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'workspace_id',
            'process_run_id',
            'limit'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_process_run_outputs" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats: Dict[str, str] = {}

        # process the path parameters
        _path_params: Dict[str, str] = {}
        if _params['workspace_id'] is not None:
            _path_params['workspace_id'] = _params['workspace_id']


        # process the query parameters
        _query_params: List[Tuple[str, str]] = []
        if _params.get('process_run_id') is not None:  # noqa: E501
            _query_params.append(('process_run_id', _params['process_run_id']))

        if _params.get('limit') is not None:  # noqa: E501
            _query_params.append(('limit', _params['limit']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings: List[str] = ['API Key with permissions']  # noqa: E501

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ListProcessRunOutputs200Response",
            '403': "GenericErrorResponse",
        }

        return self.api_client.call_api(
            '/workspaces/{workspace_id}/outputs', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_call
    def list_process_runs(
        self,
        workspace_id: Annotated[StrictStr, Field(description="Workspace ID")],
        process_id: Annotated[Optional[StrictStr], Field(description="Process ID, if specified, the response will only contain the process runs from this process")] = None,
        state: Annotated[Optional[StrictStr], Field(description="State of process runs")] = None,
        limit: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Limit for paginated response")] = None,
        **kwargs,
    ) -> ListProcessRuns200Response:
        """List process runs  # noqa: E501

        Returns a paginated list of process runs. If a process id is specified in the query parameters, the response will only contain process runs from that process. If not, the response will contain the process runs of the workspace in the path.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.list_process_runs(workspace_id, process_id, state, limit, async_req=True)
        >>> result = thread.get()

        :param workspace_id: Workspace ID (required)
        :type workspace_id: str
        :param process_id: Process ID, if specified, the response will only contain the process runs from this process
        :type process_id: str
        :param state: State of process runs
        :type state: str
        :param limit: Limit for paginated response
        :type limit: float
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ListProcessRuns200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the list_process_runs_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)

        return self.list_process_runs_with_http_info.raw_function(
            workspace_id,
            process_id,
            state,
            limit,
            **kwargs,
        )

    @validate_call
    def list_process_runs_with_http_info(
        self,
        workspace_id: Annotated[StrictStr, Field(description="Workspace ID")],
        process_id: Annotated[Optional[StrictStr], Field(description="Process ID, if specified, the response will only contain the process runs from this process")] = None,
        state: Annotated[Optional[StrictStr], Field(description="State of process runs")] = None,
        limit: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Limit for paginated response")] = None,
        **kwargs,
    ) -> ApiResponse:
        """List process runs  # noqa: E501

        Returns a paginated list of process runs. If a process id is specified in the query parameters, the response will only contain process runs from that process. If not, the response will contain the process runs of the workspace in the path.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.list_process_runs_with_http_info(workspace_id, process_id, state, limit, async_req=True)
        >>> result = thread.get()

        :param workspace_id: Workspace ID (required)
        :type workspace_id: str
        :param process_id: Process ID, if specified, the response will only contain the process runs from this process
        :type process_id: str
        :param state: State of process runs
        :type state: str
        :param limit: Limit for paginated response
        :type limit: float
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ListProcessRuns200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'workspace_id',
            'process_id',
            'state',
            'limit'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method list_process_runs" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats: Dict[str, str] = {}

        # process the path parameters
        _path_params: Dict[str, str] = {}
        if _params['workspace_id'] is not None:
            _path_params['workspace_id'] = _params['workspace_id']


        # process the query parameters
        _query_params: List[Tuple[str, str]] = []
        if _params.get('process_id') is not None:  # noqa: E501
            _query_params.append(('process_id', _params['process_id']))

        if _params.get('state') is not None:  # noqa: E501
            _query_params.append(('state', _params['state']))

        if _params.get('limit') is not None:  # noqa: E501
            _query_params.append(('limit', _params['limit']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings: List[str] = ['API Key with permissions']  # noqa: E501

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ListProcessRuns200Response",
            '403': "GenericErrorResponse",
        }

        return self.api_client.call_api(
            '/workspaces/{workspace_id}/process-runs', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_call
    def start_process_run(
        self,
        workspace_id: Annotated[StrictStr, Field(description="The id of the workspace on which the process resides.")],
        process_id: Annotated[StrictStr, Field(description="The id of the process to start.")],
        start_process_run_request: Annotated[Optional[StartProcessRunRequest], Field(description="Omitting the request body will start a process run with either the default work item, if configured, or an empty work item. ")] = None,
        **kwargs,
    ) -> StartProcessRun200Response:
        """Start process run  # noqa: E501

        Starts a process run for the requested process. You may choose to start a process run without work items, with specified work items, or with the work items that are waiting in the input queue of the specified process.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.start_process_run(workspace_id, process_id, start_process_run_request, async_req=True)
        >>> result = thread.get()

        :param workspace_id: The id of the workspace on which the process resides. (required)
        :type workspace_id: str
        :param process_id: The id of the process to start. (required)
        :type process_id: str
        :param start_process_run_request: Omitting the request body will start a process run with either the default work item, if configured, or an empty work item. 
        :type start_process_run_request: StartProcessRunRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: StartProcessRun200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the start_process_run_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)

        return self.start_process_run_with_http_info.raw_function(
            workspace_id,
            process_id,
            start_process_run_request,
            **kwargs,
        )

    @validate_call
    def start_process_run_with_http_info(
        self,
        workspace_id: Annotated[StrictStr, Field(description="The id of the workspace on which the process resides.")],
        process_id: Annotated[StrictStr, Field(description="The id of the process to start.")],
        start_process_run_request: Annotated[Optional[StartProcessRunRequest], Field(description="Omitting the request body will start a process run with either the default work item, if configured, or an empty work item. ")] = None,
        **kwargs,
    ) -> ApiResponse:
        """Start process run  # noqa: E501

        Starts a process run for the requested process. You may choose to start a process run without work items, with specified work items, or with the work items that are waiting in the input queue of the specified process.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.start_process_run_with_http_info(workspace_id, process_id, start_process_run_request, async_req=True)
        >>> result = thread.get()

        :param workspace_id: The id of the workspace on which the process resides. (required)
        :type workspace_id: str
        :param process_id: The id of the process to start. (required)
        :type process_id: str
        :param start_process_run_request: Omitting the request body will start a process run with either the default work item, if configured, or an empty work item. 
        :type start_process_run_request: StartProcessRunRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(StartProcessRun200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'workspace_id',
            'process_id',
            'start_process_run_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method start_process_run" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats: Dict[str, str] = {}

        # process the path parameters
        _path_params: Dict[str, str] = {}
        if _params['workspace_id'] is not None:
            _path_params['workspace_id'] = _params['workspace_id']

        if _params['process_id'] is not None:
            _path_params['process_id'] = _params['process_id']


        # process the query parameters
        _query_params: List[Tuple[str, str]] = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        # process the body parameter
        _body_params = None
        if _params['start_process_run_request'] is not None:
            _body_params = _params['start_process_run_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings: List[str] = ['API Key with permissions']  # noqa: E501

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "StartProcessRun200Response",
            '400': "GenericErrorResponse",
            '403': "GenericErrorResponse",
            '409': "GenericErrorResponse",
        }

        return self.api_client.call_api(
            '/workspaces/{workspace_id}/processes/{process_id}/process-runs', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_call
    def start_process_run_qs_auth(
        self,
        workspace_id: Annotated[StrictStr, Field(description="Workspace ID")],
        process_id: Annotated[StrictStr, Field(description="Process ID")],
        token: Annotated[StrictStr, Field(description="Authorization token")],
        any_valid_json: Annotated[Optional[AnyValidJson], Field(description="Any valid JSON payload. The full request body is passed as a work item to the process run input. ")],
        with_handshake: Annotated[Optional[StrictStr], Field(description="Handshake type")] = None,
        **kwargs,
    ) -> StartProcessRunQsAuth200Response:
        """Start process run (for integrations)  # noqa: E501

        Starts a process run for the requested process. This endpoint is useful when you don't have control over the **headers** and / or **request body** of the caller and need a plain URL. This includes e.g. certain integration cases. The **full request body** will be provided as the input work item for the process run. The **API Key** must be provided as the value of the `token` query-string parameter. This endpoint supports **webhook handshakes** for added security. Currently we support the protocol employed by [Asana](https://asana.com/). If you are using Asana, use the `with_handshake=asana` query string parameter when constructing the URL to enable Asana webhook handshakes.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.start_process_run_qs_auth(workspace_id, process_id, token, any_valid_json, with_handshake, async_req=True)
        >>> result = thread.get()

        :param workspace_id: Workspace ID (required)
        :type workspace_id: str
        :param process_id: Process ID (required)
        :type process_id: str
        :param token: Authorization token (required)
        :type token: str
        :param any_valid_json: Any valid JSON payload. The full request body is passed as a work item to the process run input.  (required)
        :type any_valid_json: AnyValidJson
        :param with_handshake: Handshake type
        :type with_handshake: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: StartProcessRunQsAuth200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the start_process_run_qs_auth_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)

        return self.start_process_run_qs_auth_with_http_info.raw_function(
            workspace_id,
            process_id,
            token,
            any_valid_json,
            with_handshake,
            **kwargs,
        )

    @validate_call
    def start_process_run_qs_auth_with_http_info(
        self,
        workspace_id: Annotated[StrictStr, Field(description="Workspace ID")],
        process_id: Annotated[StrictStr, Field(description="Process ID")],
        token: Annotated[StrictStr, Field(description="Authorization token")],
        any_valid_json: Annotated[Optional[AnyValidJson], Field(description="Any valid JSON payload. The full request body is passed as a work item to the process run input. ")],
        with_handshake: Annotated[Optional[StrictStr], Field(description="Handshake type")] = None,
        **kwargs,
    ) -> ApiResponse:
        """Start process run (for integrations)  # noqa: E501

        Starts a process run for the requested process. This endpoint is useful when you don't have control over the **headers** and / or **request body** of the caller and need a plain URL. This includes e.g. certain integration cases. The **full request body** will be provided as the input work item for the process run. The **API Key** must be provided as the value of the `token` query-string parameter. This endpoint supports **webhook handshakes** for added security. Currently we support the protocol employed by [Asana](https://asana.com/). If you are using Asana, use the `with_handshake=asana` query string parameter when constructing the URL to enable Asana webhook handshakes.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.start_process_run_qs_auth_with_http_info(workspace_id, process_id, token, any_valid_json, with_handshake, async_req=True)
        >>> result = thread.get()

        :param workspace_id: Workspace ID (required)
        :type workspace_id: str
        :param process_id: Process ID (required)
        :type process_id: str
        :param token: Authorization token (required)
        :type token: str
        :param any_valid_json: Any valid JSON payload. The full request body is passed as a work item to the process run input.  (required)
        :type any_valid_json: AnyValidJson
        :param with_handshake: Handshake type
        :type with_handshake: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(StartProcessRunQsAuth200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'workspace_id',
            'process_id',
            'token',
            'any_valid_json',
            'with_handshake'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method start_process_run_qs_auth" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats: Dict[str, str] = {}

        # process the path parameters
        _path_params: Dict[str, str] = {}
        if _params['workspace_id'] is not None:
            _path_params['workspace_id'] = _params['workspace_id']

        if _params['process_id'] is not None:
            _path_params['process_id'] = _params['process_id']


        # process the query parameters
        _query_params: List[Tuple[str, str]] = []
        if _params.get('token') is not None:  # noqa: E501
            _query_params.append(('token', _params['token']))

        if _params.get('with_handshake') is not None:  # noqa: E501
            _query_params.append(('with_handshake', _params['with_handshake']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        # process the body parameter
        _body_params = None
        if _params['any_valid_json'] is not None:
            _body_params = _params['any_valid_json']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings: List[str] = ['API Key with permissions']  # noqa: E501

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "StartProcessRunQsAuth200Response",
            '400': "GenericErrorResponse",
        }

        return self.api_client.call_api(
            '/workspaces/{workspace_id}/processes/{process_id}/process-runs-integrations', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_call
    def stop_process_run(
        self,
        workspace_id: Annotated[StrictStr, Field(description="The id of the workspace on which the process run resides.")],
        process_run_id: Annotated[StrictStr, Field(description="The id of the process run to stop.")],
        stop_process_run_request: Annotated[StopProcessRunRequest, Field(description="Set whether or not to set the remaining work items as done or terminating the ongoing activity runs, as well as the reason for stopping the process run.")],
        **kwargs,
    ) -> StopProcessRun200Response:
        """Stop process run  # noqa: E501

        Stops the process run.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stop_process_run(workspace_id, process_run_id, stop_process_run_request, async_req=True)
        >>> result = thread.get()

        :param workspace_id: The id of the workspace on which the process run resides. (required)
        :type workspace_id: str
        :param process_run_id: The id of the process run to stop. (required)
        :type process_run_id: str
        :param stop_process_run_request: Set whether or not to set the remaining work items as done or terminating the ongoing activity runs, as well as the reason for stopping the process run. (required)
        :type stop_process_run_request: StopProcessRunRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request.
               If one number provided, it will be total request
               timeout. It can also be a pair (tuple) of
               (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: StopProcessRun200Response
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            message = "Error! Please call the stop_process_run_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"  # noqa: E501
            raise ValueError(message)

        return self.stop_process_run_with_http_info.raw_function(
            workspace_id,
            process_run_id,
            stop_process_run_request,
            **kwargs,
        )

    @validate_call
    def stop_process_run_with_http_info(
        self,
        workspace_id: Annotated[StrictStr, Field(description="The id of the workspace on which the process run resides.")],
        process_run_id: Annotated[StrictStr, Field(description="The id of the process run to stop.")],
        stop_process_run_request: Annotated[StopProcessRunRequest, Field(description="Set whether or not to set the remaining work items as done or terminating the ongoing activity runs, as well as the reason for stopping the process run.")],
        **kwargs,
    ) -> ApiResponse:
        """Stop process run  # noqa: E501

        Stops the process run.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.stop_process_run_with_http_info(workspace_id, process_run_id, stop_process_run_request, async_req=True)
        >>> result = thread.get()

        :param workspace_id: The id of the workspace on which the process run resides. (required)
        :type workspace_id: str
        :param process_run_id: The id of the process run to stop. (required)
        :type process_run_id: str
        :param stop_process_run_request: Set whether or not to set the remaining work items as done or terminating the ongoing activity runs, as well as the reason for stopping the process run. (required)
        :type stop_process_run_request: StopProcessRunRequest
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(StopProcessRun200Response, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'workspace_id',
            'process_run_id',
            'stop_process_run_request'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method stop_process_run" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats: Dict[str, str] = {}

        # process the path parameters
        _path_params: Dict[str, str] = {}
        if _params['workspace_id'] is not None:
            _path_params['workspace_id'] = _params['workspace_id']

        if _params['process_run_id'] is not None:
            _path_params['process_run_id'] = _params['process_run_id']


        # process the query parameters
        _query_params: List[Tuple[str, str]] = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[str, str] = {}
        # process the body parameter
        _body_params = None
        if _params['stop_process_run_request'] is not None:
            _body_params = _params['stop_process_run_request']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings: List[str] = ['API Key with permissions']  # noqa: E501

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "StopProcessRun200Response",
            '400': "GenericErrorResponse",
            '403': "GenericErrorResponse",
            '404': "GenericErrorResponse",
        }

        return self.api_client.call_api(
            '/workspaces/{workspace_id}/process-runs/{process_run_id}/stop', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))
